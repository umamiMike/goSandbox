// Package models contains the types for schema 'AllergyNew'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"

	"github.com/go-sql-driver/mysql"
)

// Formula represents a row from 'AllergyNew.formulas'.
type Formula struct {
	ID            uint           `json:"id"`             // id
	PracticeID    sql.NullInt64  `json:"practice_id"`    // practice_id
	LocationID    sql.NullInt64  `json:"location_id"`    // location_id
	PatientID     sql.NullInt64  `json:"patient_id"`     // patient_id
	CreateDate    mysql.NullTime `json:"create_date"`    // create_date
	CreatedBy     sql.NullInt64  `json:"created_by"`     // created_by
	CloseDate     mysql.NullTime `json:"close_date"`     // close_date
	Reason        sql.NullString `json:"reason"`         // reason
	Locked        int8           `json:"locked"`         // locked
	Status        Status         `json:"status"`         // status
	TreatmentType TreatmentType  `json:"treatment_type"` // treatment_type
	MixMethod     MixMethod      `json:"mix_method"`     // mix_method
	Interval      sql.NullString `json:"interval"`       // interval
	IsChild       sql.NullInt64  `json:"is_child"`       // is_child
	Archived      int8           `json:"archived"`       // archived
	Verified      int8           `json:"verified"`       // verified
	VerifiedDate  mysql.NullTime `json:"verified_date"`  // verified_date
	VerifiedBy    sql.NullInt64  `json:"verified_by"`    // verified_by
	Signed        int8           `json:"signed"`         // signed
	SignedDate    mysql.NullTime `json:"signed_date"`    // signed_date
	SignedBy      sql.NullInt64  `json:"signed_by"`      // signed_by
	EditDate      mysql.NullTime `json:"edit_date"`      // edit_date
	EditedBy      sql.NullInt64  `json:"edited_by"`      // edited_by
	Comments      sql.NullString `json:"comments"`       // comments
	UpdatedBy     sql.NullInt64  `json:"updated_by"`     // updated_by
	Updated       time.Time      `json:"updated"`        // updated

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the Formula exists in the database.
func (f *Formula) Exists() bool {
	return f._exists
}

// Deleted provides information if the Formula has been deleted from the database.
func (f *Formula) Deleted() bool {
	return f._deleted
}

// Insert inserts the Formula to the database.
func (f *Formula) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if f._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO AllergyNew.formulas (` +
		`practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, f.PracticeID, f.LocationID, f.PatientID, f.CreateDate, f.CreatedBy, f.CloseDate, f.Reason, f.Locked, f.Status, f.TreatmentType, f.MixMethod, f.Interval, f.IsChild, f.Archived, f.Verified, f.VerifiedDate, f.VerifiedBy, f.Signed, f.SignedDate, f.SignedBy, f.EditDate, f.EditedBy, f.Comments, f.UpdatedBy, f.Updated)
	res, err := db.Exec(sqlstr, f.PracticeID, f.LocationID, f.PatientID, f.CreateDate, f.CreatedBy, f.CloseDate, f.Reason, f.Locked, f.Status, f.TreatmentType, f.MixMethod, f.Interval, f.IsChild, f.Archived, f.Verified, f.VerifiedDate, f.VerifiedBy, f.Signed, f.SignedDate, f.SignedBy, f.EditDate, f.EditedBy, f.Comments, f.UpdatedBy, f.Updated)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	f.ID = uint(id)
	f._exists = true

	return nil
}

// Update updates the Formula in the database.
func (f *Formula) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !f._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if f._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE AllergyNew.formulas SET ` +
		`practice_id = ?, location_id = ?, patient_id = ?, create_date = ?, created_by = ?, close_date = ?, reason = ?, locked = ?, status = ?, treatment_type = ?, mix_method = ?, interval = ?, is_child = ?, archived = ?, verified = ?, verified_date = ?, verified_by = ?, signed = ?, signed_date = ?, signed_by = ?, edit_date = ?, edited_by = ?, comments = ?, updated_by = ?, updated = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, f.PracticeID, f.LocationID, f.PatientID, f.CreateDate, f.CreatedBy, f.CloseDate, f.Reason, f.Locked, f.Status, f.TreatmentType, f.MixMethod, f.Interval, f.IsChild, f.Archived, f.Verified, f.VerifiedDate, f.VerifiedBy, f.Signed, f.SignedDate, f.SignedBy, f.EditDate, f.EditedBy, f.Comments, f.UpdatedBy, f.Updated, f.ID)
	_, err = db.Exec(sqlstr, f.PracticeID, f.LocationID, f.PatientID, f.CreateDate, f.CreatedBy, f.CloseDate, f.Reason, f.Locked, f.Status, f.TreatmentType, f.MixMethod, f.Interval, f.IsChild, f.Archived, f.Verified, f.VerifiedDate, f.VerifiedBy, f.Signed, f.SignedDate, f.SignedBy, f.EditDate, f.EditedBy, f.Comments, f.UpdatedBy, f.Updated, f.ID)
	return err
}

// Save saves the Formula to the database.
func (f *Formula) Save(db XODB) error {
	if f.Exists() {
		return f.Update(db)
	}

	return f.Insert(db)
}

// Delete deletes the Formula from the database.
func (f *Formula) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !f._exists {
		return nil
	}

	// if deleted, bail
	if f._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM AllergyNew.formulas WHERE id = ?`

	// run query
	XOLog(sqlstr, f.ID)
	_, err = db.Exec(sqlstr, f.ID)
	if err != nil {
		return err
	}

	// set deleted
	f._deleted = true

	return nil
}

// PracticeLocation returns the PracticeLocation associated with the Formula's LocationID (location_id).
//
// Generated from foreign key 'formulas_location'.
func (f *Formula) PracticeLocation(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(f.LocationID.Int64))
}

// Patient returns the Patient associated with the Formula's PatientID (patient_id).
//
// Generated from foreign key 'formulas_patient'.
func (f *Formula) Patient(db XODB) (*Patient, error) {
	return PatientByID(db, uint(f.PatientID.Int64))
}

// Practice returns the Practice associated with the Formula's PracticeID (practice_id).
//
// Generated from foreign key 'formulas_practice'.
func (f *Formula) Practice(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(f.PracticeID.Int64))
}

// UserByUpdatedBy returns the User associated with the Formula's UpdatedBy (updated_by).
//
// Generated from foreign key 'formulas_updated'.
func (f *Formula) UserByUpdatedBy(db XODB) (*User, error) {
	return UserByID(db, uint(f.UpdatedBy.Int64))
}

// UserByVerifiedBy returns the User associated with the Formula's VerifiedBy (verified_by).
//
// Generated from foreign key 'formulas_verified_by'.
func (f *Formula) UserByVerifiedBy(db XODB) (*User, error) {
	return UserByID(db, uint(f.VerifiedBy.Int64))
}

// FormulasByLocationID retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'Locations'.
func FormulasByLocationID(db XODB, locationID sql.NullInt64) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE location_id = ?`

	// run query
	XOLog(sqlstr, locationID)
	q, err := db.Query(sqlstr, locationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulasByPatientID retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'Patients'.
func FormulasByPatientID(db XODB, patientID sql.NullInt64) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE patient_id = ?`

	// run query
	XOLog(sqlstr, patientID)
	q, err := db.Query(sqlstr, patientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulasByPracticeID retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'Practices'.
func FormulasByPracticeID(db XODB, practiceID sql.NullInt64) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE practice_id = ?`

	// run query
	XOLog(sqlstr, practiceID)
	q, err := db.Query(sqlstr, practiceID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulaByID retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'formulas_id_pkey'.
func FormulaByID(db XODB, id uint) (*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	f := Formula{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
	if err != nil {
		return nil, err
	}

	return &f, nil
}

// FormulasByStatus retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'formulas_status'.
func FormulasByStatus(db XODB, status Status) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE status = ?`

	// run query
	XOLog(sqlstr, status)
	q, err := db.Query(sqlstr, status)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulasByUpdatedBy retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'formulas_updated'.
func FormulasByUpdatedBy(db XODB, updatedBy sql.NullInt64) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE updated_by = ?`

	// run query
	XOLog(sqlstr, updatedBy)
	q, err := db.Query(sqlstr, updatedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulasByVerifiedBy retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'formulas_verified_by'.
func FormulasByVerifiedBy(db XODB, verifiedBy sql.NullInt64) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE verified_by = ?`

	// run query
	XOLog(sqlstr, verifiedBy)
	q, err := db.Query(sqlstr, verifiedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}

// FormulasByVerifiedDate retrieves a row from 'AllergyNew.formulas' as a Formula.
//
// Generated from index 'formulas_verifieddate'.
func FormulasByVerifiedDate(db XODB, verifiedDate mysql.NullTime) ([]*Formula, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, practice_id, location_id, patient_id, create_date, created_by, close_date, reason, locked, status, treatment_type, mix_method, interval, is_child, archived, verified, verified_date, verified_by, signed, signed_date, signed_by, edit_date, edited_by, comments, updated_by, updated ` +
		`FROM AllergyNew.formulas ` +
		`WHERE verified_date = ?`

	// run query
	XOLog(sqlstr, verifiedDate)
	q, err := db.Query(sqlstr, verifiedDate)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*Formula{}
	for q.Next() {
		f := Formula{
			_exists: true,
		}

		// scan
		err = q.Scan(&f.ID, &f.PracticeID, &f.LocationID, &f.PatientID, &f.CreateDate, &f.CreatedBy, &f.CloseDate, &f.Reason, &f.Locked, &f.Status, &f.TreatmentType, &f.MixMethod, &f.Interval, &f.IsChild, &f.Archived, &f.Verified, &f.VerifiedDate, &f.VerifiedBy, &f.Signed, &f.SignedDate, &f.SignedBy, &f.EditDate, &f.EditedBy, &f.Comments, &f.UpdatedBy, &f.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &f)
	}

	return res, nil
}
