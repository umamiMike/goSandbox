// Package models contains the types for schema 'AllergyNew'.
package models

// Code generated by xo. DO NOT EDIT.

import (
	"database/sql"
	"errors"
	"time"

	"github.com/go-sql-driver/mysql"
)

// IgeTest represents a row from 'AllergyNew.ige_tests'.
type IgeTest struct {
	ID                   uint            `json:"id"`                      // id
	PatientID            sql.NullInt64   `json:"patient_id"`              // patient_id
	OrderID              sql.NullInt64   `json:"order_id"`                // order_id
	Status               Status          `json:"status"`                  // status
	CurrentLocationID    sql.NullInt64   `json:"current_location_id"`     // current_location_id
	StartDate            mysql.NullTime  `json:"start_date"`              // start_date
	StartPracticeID      sql.NullInt64   `json:"start_practice_id"`       // start_practice_id
	StartLocationID      sql.NullInt64   `json:"start_location_id"`       // start_location_id
	StartedBy            sql.NullInt64   `json:"started_by"`              // started_by
	BloodDrawnDate       mysql.NullTime  `json:"blood_drawn_date"`        // blood_drawn_date
	BloodDrawnPracticeID sql.NullInt64   `json:"blood_drawn_practice_id"` // blood_drawn_practice_id
	BloodDrawnLocationID sql.NullInt64   `json:"blood_drawn_location_id"` // blood_drawn_location_id
	BloodDrawnBy         sql.NullInt64   `json:"blood_drawn_by"`          // blood_drawn_by
	BloodToPracticeID    sql.NullInt64   `json:"blood_to_practice_id"`    // blood_to_practice_id
	BloodToLocationID    sql.NullInt64   `json:"blood_to_location_id"`    // blood_to_location_id
	BloodToAddress       sql.NullString  `json:"blood_to_address"`        // blood_to_address
	BloodReceivedDate    mysql.NullTime  `json:"blood_received_date"`     // blood_received_date
	BloodReceivedBy      sql.NullInt64   `json:"blood_received_by"`       // blood_received_by
	CloseDate            mysql.NullTime  `json:"close_date"`              // close_date
	ClosePracticeID      sql.NullInt64   `json:"close_practice_id"`       // close_practice_id
	CloseLocationID      sql.NullInt64   `json:"close_location_id"`       // close_location_id
	ClosedBy             sql.NullInt64   `json:"closed_by"`               // closed_by
	ReviewedDate         mysql.NullTime  `json:"reviewed_date"`           // reviewed_date
	ReviewedPracticeID   sql.NullInt64   `json:"reviewed_practice_id"`    // reviewed_practice_id
	ReviewedLocationID   sql.NullInt64   `json:"reviewed_location_id"`    // reviewed_location_id
	ReviewedBy           sql.NullInt64   `json:"reviewed_by"`             // reviewed_by
	Control              sql.NullFloat64 `json:"control"`                 // control
	Notes                sql.NullString  `json:"notes"`                   // notes
	RecommendTreatment   sql.NullInt64   `json:"recommend_treatment"`     // recommend_treatment
	RecommendID          sql.NullInt64   `json:"recommend_id"`            // recommend_id
	BillableEventID      sql.NullInt64   `json:"billable_event_id"`       // billable_event_id
	Signed               int8            `json:"signed"`                  // signed
	SignedDate           mysql.NullTime  `json:"signed_date"`             // signed_date
	SignedBy             sql.NullInt64   `json:"signed_by"`               // signed_by
	ReopenedDate         mysql.NullTime  `json:"reopened_date"`           // reopened_date
	ReopenedBy           sql.NullInt64   `json:"reopened_by"`             // reopened_by
	EmrOrdersID          sql.NullInt64   `json:"emr_orders_id"`           // emr_orders_id
	UpdatedBy            sql.NullInt64   `json:"updated_by"`              // updated_by
	Updated              time.Time       `json:"updated"`                 // updated

	// xo fields
	_exists, _deleted bool
}

// Exists determines if the IgeTest exists in the database.
func (it *IgeTest) Exists() bool {
	return it._exists
}

// Deleted provides information if the IgeTest has been deleted from the database.
func (it *IgeTest) Deleted() bool {
	return it._deleted
}

// Insert inserts the IgeTest to the database.
func (it *IgeTest) Insert(db XODB) error {
	var err error

	// if already exist, bail
	if it._exists {
		return errors.New("insert failed: already exists")
	}

	// sql insert query, primary key provided by autoincrement
	const sqlstr = `INSERT INTO AllergyNew.ige_tests (` +
		`patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated` +
		`) VALUES (` +
		`?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?` +
		`)`

	// run query
	XOLog(sqlstr, it.PatientID, it.OrderID, it.Status, it.CurrentLocationID, it.StartDate, it.StartPracticeID, it.StartLocationID, it.StartedBy, it.BloodDrawnDate, it.BloodDrawnPracticeID, it.BloodDrawnLocationID, it.BloodDrawnBy, it.BloodToPracticeID, it.BloodToLocationID, it.BloodToAddress, it.BloodReceivedDate, it.BloodReceivedBy, it.CloseDate, it.ClosePracticeID, it.CloseLocationID, it.ClosedBy, it.ReviewedDate, it.ReviewedPracticeID, it.ReviewedLocationID, it.ReviewedBy, it.Control, it.Notes, it.RecommendTreatment, it.RecommendID, it.BillableEventID, it.Signed, it.SignedDate, it.SignedBy, it.ReopenedDate, it.ReopenedBy, it.EmrOrdersID, it.UpdatedBy, it.Updated)
	res, err := db.Exec(sqlstr, it.PatientID, it.OrderID, it.Status, it.CurrentLocationID, it.StartDate, it.StartPracticeID, it.StartLocationID, it.StartedBy, it.BloodDrawnDate, it.BloodDrawnPracticeID, it.BloodDrawnLocationID, it.BloodDrawnBy, it.BloodToPracticeID, it.BloodToLocationID, it.BloodToAddress, it.BloodReceivedDate, it.BloodReceivedBy, it.CloseDate, it.ClosePracticeID, it.CloseLocationID, it.ClosedBy, it.ReviewedDate, it.ReviewedPracticeID, it.ReviewedLocationID, it.ReviewedBy, it.Control, it.Notes, it.RecommendTreatment, it.RecommendID, it.BillableEventID, it.Signed, it.SignedDate, it.SignedBy, it.ReopenedDate, it.ReopenedBy, it.EmrOrdersID, it.UpdatedBy, it.Updated)
	if err != nil {
		return err
	}

	// retrieve id
	id, err := res.LastInsertId()
	if err != nil {
		return err
	}

	// set primary key and existence
	it.ID = uint(id)
	it._exists = true

	return nil
}

// Update updates the IgeTest in the database.
func (it *IgeTest) Update(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !it._exists {
		return errors.New("update failed: does not exist")
	}

	// if deleted, bail
	if it._deleted {
		return errors.New("update failed: marked for deletion")
	}

	// sql query
	const sqlstr = `UPDATE AllergyNew.ige_tests SET ` +
		`patient_id = ?, order_id = ?, status = ?, current_location_id = ?, start_date = ?, start_practice_id = ?, start_location_id = ?, started_by = ?, blood_drawn_date = ?, blood_drawn_practice_id = ?, blood_drawn_location_id = ?, blood_drawn_by = ?, blood_to_practice_id = ?, blood_to_location_id = ?, blood_to_address = ?, blood_received_date = ?, blood_received_by = ?, close_date = ?, close_practice_id = ?, close_location_id = ?, closed_by = ?, reviewed_date = ?, reviewed_practice_id = ?, reviewed_location_id = ?, reviewed_by = ?, control = ?, notes = ?, recommend_treatment = ?, recommend_id = ?, billable_event_id = ?, signed = ?, signed_date = ?, signed_by = ?, reopened_date = ?, reopened_by = ?, emr_orders_id = ?, updated_by = ?, updated = ?` +
		` WHERE id = ?`

	// run query
	XOLog(sqlstr, it.PatientID, it.OrderID, it.Status, it.CurrentLocationID, it.StartDate, it.StartPracticeID, it.StartLocationID, it.StartedBy, it.BloodDrawnDate, it.BloodDrawnPracticeID, it.BloodDrawnLocationID, it.BloodDrawnBy, it.BloodToPracticeID, it.BloodToLocationID, it.BloodToAddress, it.BloodReceivedDate, it.BloodReceivedBy, it.CloseDate, it.ClosePracticeID, it.CloseLocationID, it.ClosedBy, it.ReviewedDate, it.ReviewedPracticeID, it.ReviewedLocationID, it.ReviewedBy, it.Control, it.Notes, it.RecommendTreatment, it.RecommendID, it.BillableEventID, it.Signed, it.SignedDate, it.SignedBy, it.ReopenedDate, it.ReopenedBy, it.EmrOrdersID, it.UpdatedBy, it.Updated, it.ID)
	_, err = db.Exec(sqlstr, it.PatientID, it.OrderID, it.Status, it.CurrentLocationID, it.StartDate, it.StartPracticeID, it.StartLocationID, it.StartedBy, it.BloodDrawnDate, it.BloodDrawnPracticeID, it.BloodDrawnLocationID, it.BloodDrawnBy, it.BloodToPracticeID, it.BloodToLocationID, it.BloodToAddress, it.BloodReceivedDate, it.BloodReceivedBy, it.CloseDate, it.ClosePracticeID, it.CloseLocationID, it.ClosedBy, it.ReviewedDate, it.ReviewedPracticeID, it.ReviewedLocationID, it.ReviewedBy, it.Control, it.Notes, it.RecommendTreatment, it.RecommendID, it.BillableEventID, it.Signed, it.SignedDate, it.SignedBy, it.ReopenedDate, it.ReopenedBy, it.EmrOrdersID, it.UpdatedBy, it.Updated, it.ID)
	return err
}

// Save saves the IgeTest to the database.
func (it *IgeTest) Save(db XODB) error {
	if it.Exists() {
		return it.Update(db)
	}

	return it.Insert(db)
}

// Delete deletes the IgeTest from the database.
func (it *IgeTest) Delete(db XODB) error {
	var err error

	// if doesn't exist, bail
	if !it._exists {
		return nil
	}

	// if deleted, bail
	if it._deleted {
		return nil
	}

	// sql query
	const sqlstr = `DELETE FROM AllergyNew.ige_tests WHERE id = ?`

	// run query
	XOLog(sqlstr, it.ID)
	_, err = db.Exec(sqlstr, it.ID)
	if err != nil {
		return err
	}

	// set deleted
	it._deleted = true

	return nil
}

// UserByBloodDrawnBy returns the User associated with the IgeTest's BloodDrawnBy (blood_drawn_by).
//
// Generated from foreign key 'rast_tests_blood_drawn_by'.
func (it *IgeTest) UserByBloodDrawnBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.BloodDrawnBy.Int64))
}

// PracticeLocationByBloodDrawnLocationID returns the PracticeLocation associated with the IgeTest's BloodDrawnLocationID (blood_drawn_location_id).
//
// Generated from foreign key 'rast_tests_blood_drawn_location'.
func (it *IgeTest) PracticeLocationByBloodDrawnLocationID(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(it.BloodDrawnLocationID.Int64))
}

// PracticeByBloodDrawnPracticeID returns the Practice associated with the IgeTest's BloodDrawnPracticeID (blood_drawn_practice_id).
//
// Generated from foreign key 'rast_tests_blood_drawn_practice'.
func (it *IgeTest) PracticeByBloodDrawnPracticeID(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(it.BloodDrawnPracticeID.Int64))
}

// UserByBloodReceivedBy returns the User associated with the IgeTest's BloodReceivedBy (blood_received_by).
//
// Generated from foreign key 'rast_tests_blood_received_by'.
func (it *IgeTest) UserByBloodReceivedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.BloodReceivedBy.Int64))
}

// PracticeLocationByBloodToLocationID returns the PracticeLocation associated with the IgeTest's BloodToLocationID (blood_to_location_id).
//
// Generated from foreign key 'rast_tests_blood_to_location'.
func (it *IgeTest) PracticeLocationByBloodToLocationID(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(it.BloodToLocationID.Int64))
}

// PracticeByBloodToPracticeID returns the Practice associated with the IgeTest's BloodToPracticeID (blood_to_practice_id).
//
// Generated from foreign key 'rast_tests_blood_to_practice'.
func (it *IgeTest) PracticeByBloodToPracticeID(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(it.BloodToPracticeID.Int64))
}

// PracticeLocationByCloseLocationID returns the PracticeLocation associated with the IgeTest's CloseLocationID (close_location_id).
//
// Generated from foreign key 'rast_tests_close_location'.
func (it *IgeTest) PracticeLocationByCloseLocationID(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(it.CloseLocationID.Int64))
}

// PracticeByClosePracticeID returns the Practice associated with the IgeTest's ClosePracticeID (close_practice_id).
//
// Generated from foreign key 'rast_tests_close_practice'.
func (it *IgeTest) PracticeByClosePracticeID(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(it.ClosePracticeID.Int64))
}

// UserByClosedBy returns the User associated with the IgeTest's ClosedBy (closed_by).
//
// Generated from foreign key 'rast_tests_closed_by'.
func (it *IgeTest) UserByClosedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.ClosedBy.Int64))
}

// Order returns the Order associated with the IgeTest's OrderID (order_id).
//
// Generated from foreign key 'rast_tests_order'.
func (it *IgeTest) Order(db XODB) (*Order, error) {
	return OrderByID(db, uint(it.OrderID.Int64))
}

// Patient returns the Patient associated with the IgeTest's PatientID (patient_id).
//
// Generated from foreign key 'rast_tests_patient'.
func (it *IgeTest) Patient(db XODB) (*Patient, error) {
	return PatientByID(db, uint(it.PatientID.Int64))
}

// UserByReopenedBy returns the User associated with the IgeTest's ReopenedBy (reopened_by).
//
// Generated from foreign key 'rast_tests_reopened_by'.
func (it *IgeTest) UserByReopenedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.ReopenedBy.Int64))
}

// UserByReviewedBy returns the User associated with the IgeTest's ReviewedBy (reviewed_by).
//
// Generated from foreign key 'rast_tests_reviewed_by'.
func (it *IgeTest) UserByReviewedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.ReviewedBy.Int64))
}

// PracticeLocationByReviewedLocationID returns the PracticeLocation associated with the IgeTest's ReviewedLocationID (reviewed_location_id).
//
// Generated from foreign key 'rast_tests_reviewed_location'.
func (it *IgeTest) PracticeLocationByReviewedLocationID(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(it.ReviewedLocationID.Int64))
}

// PracticeByReviewedPracticeID returns the Practice associated with the IgeTest's ReviewedPracticeID (reviewed_practice_id).
//
// Generated from foreign key 'rast_tests_reviewed_practice'.
func (it *IgeTest) PracticeByReviewedPracticeID(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(it.ReviewedPracticeID.Int64))
}

// PracticeLocationByStartLocationID returns the PracticeLocation associated with the IgeTest's StartLocationID (start_location_id).
//
// Generated from foreign key 'rast_tests_start_location'.
func (it *IgeTest) PracticeLocationByStartLocationID(db XODB) (*PracticeLocation, error) {
	return PracticeLocationByID(db, uint(it.StartLocationID.Int64))
}

// PracticeByStartPracticeID returns the Practice associated with the IgeTest's StartPracticeID (start_practice_id).
//
// Generated from foreign key 'rast_tests_start_practice'.
func (it *IgeTest) PracticeByStartPracticeID(db XODB) (*Practice, error) {
	return PracticeByID(db, uint(it.StartPracticeID.Int64))
}

// UserByStartedBy returns the User associated with the IgeTest's StartedBy (started_by).
//
// Generated from foreign key 'rast_tests_started_by'.
func (it *IgeTest) UserByStartedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.StartedBy.Int64))
}

// UserByUpdatedBy returns the User associated with the IgeTest's UpdatedBy (updated_by).
//
// Generated from foreign key 'rast_tests_updated'.
func (it *IgeTest) UserByUpdatedBy(db XODB) (*User, error) {
	return UserByID(db, uint(it.UpdatedBy.Int64))
}

// IgeTestsByOrderID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'Orders'.
func IgeTestsByOrderID(db XODB, orderID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE order_id = ?`

	// run query
	XOLog(sqlstr, orderID)
	q, err := db.Query(sqlstr, orderID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByPatientID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'Patients'.
func IgeTestsByPatientID(db XODB, patientID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE patient_id = ?`

	// run query
	XOLog(sqlstr, patientID)
	q, err := db.Query(sqlstr, patientID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByCloseDate retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'ige_test_closedate'.
func IgeTestsByCloseDate(db XODB, closeDate mysql.NullTime) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE close_date = ?`

	// run query
	XOLog(sqlstr, closeDate)
	q, err := db.Query(sqlstr, closeDate)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStartDate retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'ige_test_startdate'.
func IgeTestsByStartDate(db XODB, startDate mysql.NullTime) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE start_date = ?`

	// run query
	XOLog(sqlstr, startDate)
	q, err := db.Query(sqlstr, startDate)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStatus retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'ige_test_status'.
func IgeTestsByStatus(db XODB, status Status) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE status = ?`

	// run query
	XOLog(sqlstr, status)
	q, err := db.Query(sqlstr, status)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestByID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'ige_tests_id_pkey'.
func IgeTestByID(db XODB, id uint) (*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE id = ?`

	// run query
	XOLog(sqlstr, id)
	it := IgeTest{
		_exists: true,
	}

	err = db.QueryRow(sqlstr, id).Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
	if err != nil {
		return nil, err
	}

	return &it, nil
}

// IgeTestsByStatus retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'ige_tests_status'.
func IgeTestsByStatus(db XODB, status Status) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE status = ?`

	// run query
	XOLog(sqlstr, status)
	q, err := db.Query(sqlstr, status)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodDrawnBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_drawn_by'.
func IgeTestsByBloodDrawnBy(db XODB, bloodDrawnBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_drawn_by = ?`

	// run query
	XOLog(sqlstr, bloodDrawnBy)
	q, err := db.Query(sqlstr, bloodDrawnBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodDrawnLocationID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_drawn_location'.
func IgeTestsByBloodDrawnLocationID(db XODB, bloodDrawnLocationID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_drawn_location_id = ?`

	// run query
	XOLog(sqlstr, bloodDrawnLocationID)
	q, err := db.Query(sqlstr, bloodDrawnLocationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodDrawnPracticeID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_drawn_practice'.
func IgeTestsByBloodDrawnPracticeID(db XODB, bloodDrawnPracticeID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_drawn_practice_id = ?`

	// run query
	XOLog(sqlstr, bloodDrawnPracticeID)
	q, err := db.Query(sqlstr, bloodDrawnPracticeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodReceivedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_received_by'.
func IgeTestsByBloodReceivedBy(db XODB, bloodReceivedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_received_by = ?`

	// run query
	XOLog(sqlstr, bloodReceivedBy)
	q, err := db.Query(sqlstr, bloodReceivedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodToLocationID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_to_location'.
func IgeTestsByBloodToLocationID(db XODB, bloodToLocationID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_to_location_id = ?`

	// run query
	XOLog(sqlstr, bloodToLocationID)
	q, err := db.Query(sqlstr, bloodToLocationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByBloodToPracticeID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_blood_to_practice'.
func IgeTestsByBloodToPracticeID(db XODB, bloodToPracticeID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE blood_to_practice_id = ?`

	// run query
	XOLog(sqlstr, bloodToPracticeID)
	q, err := db.Query(sqlstr, bloodToPracticeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByCloseLocationID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_close_location'.
func IgeTestsByCloseLocationID(db XODB, closeLocationID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE close_location_id = ?`

	// run query
	XOLog(sqlstr, closeLocationID)
	q, err := db.Query(sqlstr, closeLocationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByClosePracticeID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_close_practice'.
func IgeTestsByClosePracticeID(db XODB, closePracticeID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE close_practice_id = ?`

	// run query
	XOLog(sqlstr, closePracticeID)
	q, err := db.Query(sqlstr, closePracticeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByClosedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_closed_by'.
func IgeTestsByClosedBy(db XODB, closedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE closed_by = ?`

	// run query
	XOLog(sqlstr, closedBy)
	q, err := db.Query(sqlstr, closedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByReopenedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_reopened_by'.
func IgeTestsByReopenedBy(db XODB, reopenedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE reopened_by = ?`

	// run query
	XOLog(sqlstr, reopenedBy)
	q, err := db.Query(sqlstr, reopenedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByReviewedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_reviewed_by'.
func IgeTestsByReviewedBy(db XODB, reviewedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE reviewed_by = ?`

	// run query
	XOLog(sqlstr, reviewedBy)
	q, err := db.Query(sqlstr, reviewedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByReviewedLocationID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_reviewed_location'.
func IgeTestsByReviewedLocationID(db XODB, reviewedLocationID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE reviewed_location_id = ?`

	// run query
	XOLog(sqlstr, reviewedLocationID)
	q, err := db.Query(sqlstr, reviewedLocationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByReviewedPracticeID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_reviewed_practice'.
func IgeTestsByReviewedPracticeID(db XODB, reviewedPracticeID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE reviewed_practice_id = ?`

	// run query
	XOLog(sqlstr, reviewedPracticeID)
	q, err := db.Query(sqlstr, reviewedPracticeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStartLocationID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_start_location'.
func IgeTestsByStartLocationID(db XODB, startLocationID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE start_location_id = ?`

	// run query
	XOLog(sqlstr, startLocationID)
	q, err := db.Query(sqlstr, startLocationID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStartPracticeID retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_start_practice'.
func IgeTestsByStartPracticeID(db XODB, startPracticeID sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE start_practice_id = ?`

	// run query
	XOLog(sqlstr, startPracticeID)
	q, err := db.Query(sqlstr, startPracticeID)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStartedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_started_by'.
func IgeTestsByStartedBy(db XODB, startedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE started_by = ?`

	// run query
	XOLog(sqlstr, startedBy)
	q, err := db.Query(sqlstr, startedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByStatus retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_status'.
func IgeTestsByStatus(db XODB, status Status) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE status = ?`

	// run query
	XOLog(sqlstr, status)
	q, err := db.Query(sqlstr, status)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}

// IgeTestsByUpdatedBy retrieves a row from 'AllergyNew.ige_tests' as a IgeTest.
//
// Generated from index 'rast_tests_updated'.
func IgeTestsByUpdatedBy(db XODB, updatedBy sql.NullInt64) ([]*IgeTest, error) {
	var err error

	// sql query
	const sqlstr = `SELECT ` +
		`id, patient_id, order_id, status, current_location_id, start_date, start_practice_id, start_location_id, started_by, blood_drawn_date, blood_drawn_practice_id, blood_drawn_location_id, blood_drawn_by, blood_to_practice_id, blood_to_location_id, blood_to_address, blood_received_date, blood_received_by, close_date, close_practice_id, close_location_id, closed_by, reviewed_date, reviewed_practice_id, reviewed_location_id, reviewed_by, control, notes, recommend_treatment, recommend_id, billable_event_id, signed, signed_date, signed_by, reopened_date, reopened_by, emr_orders_id, updated_by, updated ` +
		`FROM AllergyNew.ige_tests ` +
		`WHERE updated_by = ?`

	// run query
	XOLog(sqlstr, updatedBy)
	q, err := db.Query(sqlstr, updatedBy)
	if err != nil {
		return nil, err
	}
	defer q.Close()

	// load results
	res := []*IgeTest{}
	for q.Next() {
		it := IgeTest{
			_exists: true,
		}

		// scan
		err = q.Scan(&it.ID, &it.PatientID, &it.OrderID, &it.Status, &it.CurrentLocationID, &it.StartDate, &it.StartPracticeID, &it.StartLocationID, &it.StartedBy, &it.BloodDrawnDate, &it.BloodDrawnPracticeID, &it.BloodDrawnLocationID, &it.BloodDrawnBy, &it.BloodToPracticeID, &it.BloodToLocationID, &it.BloodToAddress, &it.BloodReceivedDate, &it.BloodReceivedBy, &it.CloseDate, &it.ClosePracticeID, &it.CloseLocationID, &it.ClosedBy, &it.ReviewedDate, &it.ReviewedPracticeID, &it.ReviewedLocationID, &it.ReviewedBy, &it.Control, &it.Notes, &it.RecommendTreatment, &it.RecommendID, &it.BillableEventID, &it.Signed, &it.SignedDate, &it.SignedBy, &it.ReopenedDate, &it.ReopenedBy, &it.EmrOrdersID, &it.UpdatedBy, &it.Updated)
		if err != nil {
			return nil, err
		}

		res = append(res, &it)
	}

	return res, nil
}
